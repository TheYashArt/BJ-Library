<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Software Engineering</title>
    <style>
        main{
            max-width: 700px;
            background-color: rgb(165, 230, 222);
            align-items: center;
            padding:20px;
            margin:20px auto;

        }
        header{
            padding:20px;
            background:linear-gradient(aqua,white);
            text-align: center;
            font-size: 15px;
            text-transform: uppercase;
            text-shadow: 3px;
        }
        .img{
            width:50%;
            margin-left: auto;
            margin-right: auto;
            display:block
        }
    </style>
</head>
<body>
    <main>
    <p>
    <header>
        <strong>1 : Introduction to Software Engineering and process models</strong><br>
    </header>
<h3><b>1. Introduction</b></h3><br>
Software development comprises of various stages. At every stage it is necessary to describe:
What the outcome is.<br>
Various factors that affects the product or outcome Team members involved<br>
Software engineering activities carried out.<br>

The activities and the order in which they are carried out can differ from project to project. This chapter focuses on understanding the concepts such as<br>
<b>i.  </b>    Software and software engineering<br>
<b>ii.	</b>    Software process <br>
<b>iii.</b>	Various process models<br>

<h3><b>2. Software</b></h3><br>

In modern era, computer has become inevitable part of life. Use of computers in different areas is possible just because of diverse application software (many times embedded) which fulfils the demand of users in these domains. Software consist of set of programs which run on different types of computers (varying in size and architecture) providing the functionalities expected by the user.
Software can be defined as product which is build and supported by software engineers over a long period. This product consists of computer programs, contents generated as a result of program execution, data structures which help these programs to manipulate the data and descriptive information about the usage and working of software in the form of hard and soft copies.
Good software is one which provides expected functionality and performance to the user and which is easy to maintain and use. As compared to hardware, software is hard to maintain and it does not 'wear out'.<br>
<br>
<h3><b>3. Nature of Software Engineering</b></h3><br>
Software is not manufactured like other products. Software is developed or engineered, i.e. a systematic, quantifiable and cost-effective approach is used in all aspects of software production starting from its initial conception, operation, efficiency, security and maintenance.<br>
A definition of Software Engineering, proposed by Fritz Bauer is as follows:<br>
<em>"The establishment and use of sound engineering principles in order to obtain economically software that is reliable and works efficiently on real machines".</em><br>
IEEE defines Software Engineering as:<br><br>

<b>"Software Engineering: </b><br>(1) The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software; that is, the application of engineering to software. <br>(2)The study of approaches as in (1)."<br>
Software engineers who are involved in this process should not only be worried about the technical issues but should also be aware about the ethical issues involved.<br><br>


<image src="/Website/diagrams/SE/fig 1.1.jpg" alt="Layers Of Software Engineering" class="img"></image><br><br>


<b>Quality:</b> Quality management is base for software engineering. Software quality can be judged using its six attributes which are as follows:<br><br>
<b>a.	Functionality:</b> If refers to the expected behaviour of the software as per the requirements of the customer.<br>
<b>b.	Reliability:</b> It is a probability of failure-free operations of the software over a specific period of time.<br>
<b>c.	Usability:</b> It refers to the ease of use of the software product.<br>
<b>d. 	Efficiency:</b> It refers to the efficient resource utilization by the software for achieving certain functionality.<br>
<b>e.   Maintainability:</b> It refers to the ability of software to support modification in order to adapt the changing requirements and environments.<br>
<b>f.	Portability:</b> It is the ability of the software to run in different environment without change.<br>
<br>
<b>i.   Process: </b>This layer tries to hold quality and technical methods together in order to deliver software in time. It defines a project context for which various documents, models, forms, reports etc. are produced.
<br>
<b>ii.  Methods:</b> This layer focuses on how to build the software. It involves various tasks such as communication with stakeholders, requirements analysis, design, coding and testing.
<br>
<b>iii. Tools: </b>This layer refers to automated or semi-automated tools which help the people involved to complete software processes more efficiently and with less errors. These tools can be integrated, i.e ., output produced by one tool can act as input for the other one, leading to efficient software development called as computer aided software engineering. 
<br>
<br>
Thus, in brief we can say that the main objective of software engineering is to develop a good quality software in time and with minimum cost. The main factors which affect the quality and productivity of the software developed are people involved, process followed and the tools used during the software development process.<br>
<br>
<h3><b>4. Changing Nature of Software</b></h3><br><br>
Over a period of time, software has evolved from a product to a service. Software works on various computing devices ranging from main frame to mobile phones. The role of software has changed drastically with the evolution in technology and now software industry is playing an important role in world's economy.
Before developing a particular software, a software engineer must know what type of software to be developed and accordingly proper design and implementation (software engineering) techniques should be applied.<br><br>
The four broad categories of software which are dominating the software industry and becoming more challenging to the software engineers are as follows:<br>
<b>i.Web Apps:</b> Web applications run on web browser and uses web technology for performing its task. The emergence of web 3.0 (also called as Semantic Web Technologies)provides not only dynamic web pages with information content and computing capabilities but also web linking, access to external APIs and flexible representation of data. Today web based systems and web applications interact with corporate database and business applications.
<br><br>
<b>ii.Mobile Applications:</b> The software which is designed specifically for mobile platforms like android, iOS, Windows. Mobile app provides a user interface and uses the local processing and storage capabilities of the device. A mobile web application access web content using the web browser specifically designed for the mobile device.
<br><br>
<b>iii.Cloud Computing:</b> Basically, allows sharing of resources. A cloud architecture can be public or private. It allows user to access resources from anywhere, anytime using any computing device which resides outside the cloud. The resources within a cloud can be applications, infrastructures and database or data structures storing data. Cloud computing is implemented using front-end and back-end service architecture. Front-end encompasses computing device and application that the client uses while back-end refers to server and related resources together with middleware to coordinate and monitor the to and from traffic.
<br><br>
<b>iv.Product-line Software:</b> It focuses on mass consumer market or specific market area. Software is developed for common functionality identified among many products within the product line. It is implemented using set of software components which are reusable.Set of outcomes resulted through software engineering and which are shared by a software product-line includes requirements, architecture, design patterns, reusable components, test cases etc.
<br><br>
<h3><b>5. Software Process</b></h3><br>
<br>
Software process is core of software engineering. Software project specifies what is to be developed as per the user's requirements as shown in figure 1.2. Software process is the set of related tasks/activities carried out in order to produce the required software (for completing the project) in time.<br>
Each task performs a well-defined function and produces concrete output. The process becomes very important because it doesn't just aim to deliver a desired software but tries to produce a high-quality software within less time and cost. Software process is not static or rigid but it is dynamic or adaptable in nature. Each of the activities and tasks resides within a framework or model, which specifies the relation between process and these activities and also the relation among the activities itself.<br>
<br>

<image src="/Website/diagrams/SE/fig 1.2.jpg"class="img" alt="Software Project"></image>


<b>5.1 The Process Framework<br></b><br>
The process framework provides a support structure for entire software engineering in the form of set of activities. These activities are applicable to all software projects irrespective of its size. Complexity and type. It mainly consists of framework activities and umbrella activities. Every framework activity includes set of actions performed for completion of the activity. Each action in turn is composed of set of tasks which completed the defined action.<br><br>
The basic activities included in generic software process framework are<br>
<br>
<b>1.	Communication:</b> In order to understand the objective, functionality, limits and features of the software it required to communicate with the customer and other stake holders before starting any technical work. This includes various meetings and reports produced as a result of the meetings.<br>
<br>
<b>2.	Planning:</b> 'Fail to plan, plan to fail. Planning always help in smooth working of a leam towards the goal. A plan created for completing the software project is called 'software project plan. This plan identifies and specifies the risks involved, resources required, sequence of technical tasks to be performed, work products produced and schedule for the work.<br>
<br>
<b>3.	Modeling: </b>An abstract representation of existing or planned system is nothing but a model. Creating model helps in better understanding of requirements and proposed design to achieve these requirements.<br>
<br>
<b>4.	Construction: </b>It involves the actual coding for the designed software and testing the code in various ways in order to identify the errors<br>
<br>
<b>5.	Deployment:</b> The complete or partial software developed is delivered to the customer. After the evaluation, the customer gives feedback for the software which can be used for further improvements.<br>
<br>
<b>5.2 Umbrella Activities<br></b><br>
These are the activities which are performed throughout the entire software project. Umbrella activities are as follows :<br>
<b>1.	Software Project Tracking and Control: <br></b>
As the name suggests, these set of activities help development team to track progress of project by comparing it against the schedule Corrective measures are taken in order to maintain the schedule.<br>
<br>
<b>2.	Formal Technical Reviews: <br></b>
Reviews the product and techniques used for the development of the product. Feedbacks received after the review help in finding bugs or errors in the product before moving to next stage.<br>
<br>
<b>3.	Software Quality Assurance: <br></b>
These are the activities which tries to ensure quality of the product developed.<br>
<br>
<b>4.	 Software Configuration Management: <br></b>
These set of activities tries to manage and control changes throughout the software process.<br>
<br>
<b>5.	Work product Preparation and Production:<br></b>
Encompasses activities that are required to create and maintain details about the work product such as models, forms, logs, documents etc.<br>
<br>
<b>6.	Re-usability Management:<br></b>
Defines and establishes mechanism for reusability of software components vii. Risk Management: These set of activities measures risk involved which may affect the quality of the product or the output of the product.<br>
<br>
<b>7.	Measurement and Metrics:<br></b>
Defines and collects measures for assessing the product so that customer satisfaction can be achieved.<br>
<br>
<b>5.3 Process Adaptation<br><br></b>
Software process should be flexible and accommodative in nature. It should be dynamic and adaptable to the project, to the team and to the organization as a whole.<br><br>
It is possible that a software process used for one project may differ with another in the following areas:<br><br>
<b>I.	</b>Sequence of activities and tasks performed and their dependencies on each other. <br>
<b>II.	</b>Identification of required work products and their dept of implementation.<br>
<b>III.</b>	Quality assurance techniques and activities used.<br>
<b>IV.	</b>Techniques and activities used for project tracking and control activities.<br>
<b>V.	</b>Stress given on details of process description.<br>
<b>VI.	</b>Level of liberty given to the software team.<br>
<b>VII.</b>	Details about the roles played by individuals in a development team.<br><br>

<h3><b>6. Generic Process Model</b></h3><br><br>
Depending on the nature and objectives of the project, different methodologies or processes are used for development of the project which are called as process model. A generic process framework or model mainly consists of two types of activities.<br><br>
<b>I.	Fundamental activities:</b> These are set of framework activities applicable regardless of the project type. It consists of communication, planning, modeling, construction and deployment as mentioned above.<br>
<b>II.	Umbrella activities:</b> These are the activities which are applied throughout the software development project. These activities help development team to manage and control progress, risk, change and quality of the project.<br><br>
Generic framework activities are used by all software models but they may have different order and emphasis given to each activity. 
Process flow specifies the way to carry these activities with respect to time and order. <br>
There are four different types of process flow,<br><br>
<b>i.	Linear Process Flow: </b>As the name suggests, each of the above-mentioned activities are carried out one after the other starting with communication till deployment as shown in figure 1.3.<br>

<image src="/Website/diagrams/SE/fig 1.3.jpg" class="img" alt="Linear Process Flow"></image><br>


<b>ii.	Iterative Process Flow: </b>In this, one or more than activities are repeated before going further as shown in figure 1.4

<image src="/Website/diagrams/SE/fig 1.4.jpg" class="img"alt="Iterative Process Flow"></image><br>


<!--PAGE 10!-->
<b>iii. Evolutionary Process Flow : </b>Here the activites are performed in cyclic manner. Each cycle of activities leads to a new software version as shown in fig. 1.5.<br>

<image src="/Website/diagrams/SE/fig 1.5.jpg"class="img"alt="Evolutionary Process Flow"></image><br>

<b>iv.Parallel Process Flow : </b>As the name suggests, one or more than one activity are performed parallely as shown in fig. 1.6.<br>

<image src="/Website/diagrams/SE/fig 1.6.jpg" class="img"alt="Parallel Process Flow"></image><br>

<b><h3>7. Prescriptive Process Models</b></h3><br>
Prescriptive process models provide orderly approach to software engineering. It specifies step by step sequence of activities addressing "how to do" the software development. All activities involved are dependent on one or other activity.
Examples of Prescriptive Models<br><br>
<b>7.1 The Waterfall Model</b><br>
It is also referred as "Traditional" or "Typical or Classic life cycle model and is the oldest model for software engineering. This model was proposed by Winston Royce in 1970. Figure 1.7 shows different phases and activities performed in each phase of waterfall model.<br>


<image src="/Website/diagrams/SE/fig 1.7.jpg"class="img"alt="Waterfall Model"></image><br>


Waterfall model follows the generic software framework activities in sequential manner. The developer completes each phase before moving to the next. As the diagram resembles cascading waterfalls this model is called as "Waterfall model"<br><br>

<b>Phases of Waterfall Model</b><br><br>

<b>1.	Communication or Requirements analysis phase: </b>
Understanding user requirements and documenting it is the basic aim of this phase. <br>
<b>2.	Planning or Scheduling Phase: </b>
This phase aims to schedule the various activities of software development. It identifies the risk involved and estimates the cost of development. It also helps in tracking the software progress. <br>
<b>3.	Modeling or Design Phase:</b>
The main goal of this phase is to design the overall system with detailed specification.<br>
<b>4.	Construction or Coding and Testing Phase: </b>
As the name suggests this phase is responsible for implementation of the system design. Various components of the system are coded and tested for ensuring accuracy.<br>
<b>5.	Deployment or Operations and Maintenance Phase:</b>
This phase aims for maintenance and successful operation of the developed software at user's end for final acceptance.<br><br>

<b>Features of Waterfall Model</b><br>
<b>i. </b>The entire development process is divided into number of phases.<br>
<b>ii.</b> It uses a linear process flow.<br>
<b>iii.</b> Each phase performs a specific task or activity.<br>
<b>iv.</b> Each phase generates certain outcome called as 'work product". <br>
<b>v. </b>Outcome of previous stage acts as input for the next stage.<br>
<b>vi. </b>Sequence of phases is strictly followed and at any stage of the project it is not possible to go back to previous stage (hence the name waterfall)<br><br>

<b>Advantages of Waterfall Model</b><br>
<b>1.</b>	It is very simple to understand and use.<br>
<b>2.</b>	As each stage is responsible for specific task, it helps in good scheduling and cost estimation.<br>
<b>3.</b>	Efficient use of resources because of good scheduling. <br>
<b>4.</b>	Work products help in judging the progress of the development process.<br><br>

<b>Limitations of Waterfall Model</b><br>
<b>1.</b>	Software projects rarely follow sequential process.<br>
<b>2.</b>	It is not easy for user to explicitly specify all requirements at the beginning of the project which the model expects.<br>
<b>3.</b>	It is unable to deal with the uncertainty which exists at the beginning of the project. <br>
<b>4.</b>	When project enters in later stages, ie., coding and testing, it becomes difficult to accommodate changes.<br>
<b>5.</b>	If a problem is identified in later stage then rectifying the problem leads to increase in cost and time for development<br><br>

<b><h3>7.2 V-Model</b></h3><br>

This model is also referred as Verification and Validation Model. Basic phases performed for software development in V model are same as waterfall model. This model is considered as an extension to the Waterfall model. In this model, actions to be carried out for ensuring the quality development are described with each fundamental phase of waterfall model. These actions involve various tests to validate the product at each stage as shown in figure 1.8. It is therefore considered as variation in the representation of waterfall model itself.<br>


<image src="/Website/diagrams/SE/fig 1.8.jpg" class="img"alt="V-Model"></image><br>


<b>Verification Phases in V-Model</b><br>
<b>i.	Requirements analysis:</b> Expectations and needs of user from the software are collected through communication with client/user.<br>

<b>ii.	 Architecture design:</b> Architecture of the entire system is designed. This design specifies various components/ modules, their dependencies on each other, brief functionalities of each component, technology details and so on.<br>

<b>iii.	Component design:</b> The entire system is broken down into smaller modules and detailed functionality of every component is specified with its expected input and output.<br>

<b>iv.	 Coding:</b> Correct and optimized code is written for implementing each component and its functionality. Suitable programming language is used for the same.<br><br>

<b>Validation Phases In V-Model </b><br>
<b>1.	Unit testing:</b> Unit tests are designed and performed to ensure error free code at a program module level. It checks the correct execution of each functionality implemented <br>
<b>2.	Integration Testing:</b> Integration testing ensures the error free and smooth working of various components/modules together.<br>
<b>3.	System Testing:</b> System testing ensures that the system as a whole is working correctly and providing the expected functionalities.<br>
<b>4.	Acceptance Testing:</b> The system is tested in user's environment before the final acceptance.<br><br>


<b>Advantages of V Model</b><br>
<b>1.</b>	Testing is planned well before coding.<br>
<b>2.</b>	 Higher chances of success over waterfall model. <br>
<b>3.</b>	Efficient for small projects when requirements are clearly specified.<br><br>

<b>Disadvantages of V-Model</b><br>
<b>1.</b>	Not flexible.<br>
<b>2.</b>	Does not work efficiently with large and complex projects. <br>
<b>3.</b>	Difficult to adapt changing requirements.<br><br>

<b>7.3 Incremental Process Model</b><br>
An incremental model tries to deliver series of increments with upgraded functionalities. Instead of developing an entire system with all its functionalities, incremental model tries to split functionalities into different pieces and develops each piece as an increment. It uses all phases of waterfall model iteratively for developing the increment.<br>
This model does not freeze the requirements at the beginning of the project like waterfall model. Incremental process model aims early delivery of software prototype/version with limited important functionalities. This increment/version is given to user and based on the feedback received further up gradation takes place. Thus, the final system is evolved through various increments.<br><br>

<b>Features of Incremental Model</b><br>
<b>i.</b>	It uses combination of linear and parallel process flows.<br>
<b>ii.</b>	Full development task is broken into smaller portions.<br>
<b>iii.</b>	Increment development process starts when preliminary version of requirements is prepared. First increment developed is a core product.<br>
<b>iv.	</b>The increment developed is then delivered to the customer at the end of each iteration. Each iteration performs fundamental activities in linear flow as shown in figure1.3. The feedback received is used to refine and expand the functionalities in the successive versions as shown in figure 1.9.<br>
<b>v.</b>	Each version delivered, add additional functionalities to the previous release until the final product is developed and deployed.<br>
<b>vi.</b>	This model is suitable for large and complex systems.<br>

<image src="/Website/diagrams/SE/fig 1.9.jpg" class="img" alt="Incremental Development"></image><br>


<b>Advantages of incremental Model</b><br>
<b>1.</b>	Cost of adapting changes during the development process is reduced as it reduces the amount of analysis and documentation to be redone.<br>
<b>2.</b>	It is easier to get feedback from the customer on the development work completed by the team.<br>
<b>3.</b>	Early delivery of useful software to the customer.<br><br>

<b>Limitations of Incremental Model</b><br>
1.	It is not cost effective to produce documentation for every version developed. <br>
2.	Development of new versions leads to messy code and structural degradation of the system.<br><br>

<b>7.4	Evolutionary Process Model </b><br>
It is mainly designed to accommodate changes and updates in business and product requirements with changing market scenario. These models are iterative in nature.<br><br>

<b>Advantages of Evolutionary Model </b><br>
<b>i.	</b>Supports fast development.<br>
<b>ii.	</b>Better handling of risks involved. <br>
<b>iii.</b>	Reduces the development cost.<br>
<b>iv.	</b>As user is involved in every stage of development reduces chances of error penetration.<br><br>

<b>Limitations of Evolutionary Model</b><br>
<b>i.	</b>Project planning is difficult because of indefinite number of iterations.<br>
<b>ii.</b>	Cannot achieve maximum speed.<br>
<b>iii.</b>	Focuses more on flexibility and extensibility rather than quality.<br><br>

<b><h4>Two Common Models</b></h4><br>

<h3><b>1. Prototyping</b></h3><br>
Main objective of prototype-based development model is to overcome the limitation of the waterfall model to freeze the requirements before design and coding. It can be used with any of the process models or as a stand-alone process model. The prototype paradigm is shown in figure 1.10.<br>


<image src="/Website/diagrams/SE/fig 1.10.jpg" class="img" alt="Prototyping Paradigm"></image><br>


<b>Features of Prototyping</b><br>

<b>i.	</b>Based on the preliminary requirements gathered through communication, a working prototype for a system is quickly designed and developed.<br>
<b>ii.</b>	This working prototype is then given to the clients and end users for use with an understanding that needs are likely to change. This prototype acts as a tool for refining the requirements further.<br>
<b>iii.</b>	As per the user's feedback prototype is updated to adapt suggested changes.<br>
<b>iv.</b>	This cycle of user demonstration and update of prototype is repeated till the user suggests changes in the system.<br>
<b>v.</b>	Once the users fix the requirements, the final requirements specification for the system is produced and the final quality system is developed. <br><br>

<b>Advantages of Prototyping</b><br>

<b>i.	</b>Effective method for software development as user gets an idea of the system and its features at early stage of the development.<br>

<b>ii.	</b>Helps in reducing various types of risks associated with the project as it provides effective tool for communication with stakeholders.<br>

<b>iii.	</b>Reduces cost of adapting changes.<br><br>

<b>Limitation of Prototyping</b><br>

<b>i.</b>Overall system quality may not be considered due to quick design and development of the project.<br>

<b>ii.</b>Inappropriate algorithms and programming languages might be used during fast development.<br>

<b>iii.</b>Throw away prototypes may increase the cost of development.<br><br>


<b><h3>2. Spiral Model</h3></b><br>

It was proposed by Barry Boehm in 1986. It also considered as a risk-driven model. It combines the sequential approach of waterfall model with cyclic nature of prototyping. It follows evolutionary approach and each cycle consists of all the activities from the generic process framework model starting from communication to deployment. Each cycle involves risk assessment (i.e. whether to proceed or not decisions are taken after each complete spiral) and the software is developed in series of releases.<br>

The first cycle develops product specification which is core of the development process. Subsequent cycles develop a prototype and progress towards the actual, quality software. Figure 1.11, shows a typical spiral model.<br><br>
Each cycle in the spiral contains following activities:
<b>i.	</b>Objective settings: Objectives are set for each cycle and various methods for achieving those are identified.<br>

<b>ii.	</b>Risk assessment and reduction: In this phase, risks and constraints involved with various alternatives is assessed.<br>

<b>iii.</b>	Development and validation: Actual development and validation task is performed here that is a prototype or simulation of the system is developed.<br>

<b>iv.	</b>Planning: The project progress is assessed and it is decided whether to go for next cycle of the spiral. Based on the result of assessment next cycle is planned.<br>


<image src="/Website/diagrams/SE/fig 1.11.jpg" class="img" alt="Spiral Model"></image><br>


<b>Advantages of Spiral Model</b><br>
<b>i.	</b>Considers the entire software life cycle.<br>
<b>ii.	</b>Suitable for large and complex software.<br>
<b>iii.</b>	Better understanding and handling of risk at each evolutionary level by both developer and customer.<br><br>

<b>Limitations of Spiral Model</b><br>
<b>i.	</b>It requires expertise in managing and assessing risk.<br>
<b>ii.</b>	Convincing customer for such evolutionary approach is difficult.<br><br>

<b>7.5 Concurrent Model</b><br>
This model is used by the software development team to represent elements of any model which are iterative and parallel. It is also referred as concurrent engineering. It helps in identifying correct state of the current project.<br>
All software engineering activities are present at same time (concurrently) but in different states. As the activity progress, it changes its state as shown in figure 1.12. <br>Activity can be in any one of the following states:<br>

<b>i.	Inactive: </b>Not yet started.<br>
<b>ii.	Under development:</b> Indicates partial progress.<br>
<b>iii.	Under review:</b> Assessment of the implementation done till now. <br>
<b>iv.	Base-lined: </b>Compared with the expected requirements. jv.<br>
<b>v.	Done:</b> Completed as per the specification.<br>
<b>vi.	Awaiting changes: </b>Waiting for feedback and suggestions.<br>
<b>vii.	Under revision:</b> Going through suggested updates.<br><br>


<image src="/Website/diagrams/SE/fig 1.12.jpg" class="img" alt="one element of concurrent process model"></image><br>


<b>Advantages of Concurrent Model</b><br>

<b>i.	</b>Fast development.<br>
<b>ii.	</b>It is applicable to all types of software development processes.<br>
<b>iii.</b>	It is easy to understand.<br>
<b>iv.	</b>Gives immediate feedback.<br><br>

<b> Limitations of Concurrent Model</b><br>

<b>i.	</b>Needs better communication among team members.<br>
<b>ii.</b>	Remembering states of activities is essential.<br><br>

<b>7.6 The Unified Process</b><br><br>
The unified process tries to extract best of all traditional models. The process flow in unified process is incremental, iterative and highly focused on customer involvement. It is mainly designed for object-oriented development using UML(Unified Modeling Language).<br>
The UP is divided into cycles and each cycle consists of four consecutive phases. Thus each phase may have multiple iterations and each cycle generates a well-defined outcome. <br>Phases of Unified Process are as follows:<br>
<b>i.Inception Phase:</b> Inception phase mainly focuses on objectives, business requirements and scope of a project. It involves communication and planning activities. Fundamental requirements are described using use cases. Plan is prepared for incremental and iterative development of a project. It defines a schedule by identifying resources required and key risk factors involved.<br><br>
<b>ii.	Elaboration Phase: </b>At the end of this phase, most of the requirements of the system are identified. It involves communication and modeling activities. This phase refines the preliminary requirements specified using use cases in inception phase and specifies five different views of the software using use case model, analysis model, design model, implementation model and deployment model. Critical decision regarding the technology to be used is taken. This phase also helps in doing the cost analysis regarding the project and modification of the plan developed earlier.<br><br>
<b>iii.Construction Phase:</b> This phase results in the actual software increment. Different software components are integrated together and software increment is developed and tested (using unit testing, integration testing and acceptance testing). Analysis and design. models developed in elaboration are thus completed here.<br><br>
<b>iv.	Transition Phase: </b>The outcome of this phase is product release. Here the developed software is transferred for beta testing to client's environment. All supporting documents like user manuals, installation procedures etc. are also delivered to the client together with the software. When feedback received from user is used in identifying the defects in the system and initiating necessary updates, it is referred to as Production phase. Thus, production phase coincides with the deployment activities.<br><br>


<image src="/Website/diagrams/SE/fig 1.13.jpg" class="img" alt="Unified Process"></image><br><br>

<image src="/Website/diagrams/SE/fig 1.14.jpg" class="img" alt="Comparing Costs"></image><br><br>




<h3>Summary</h3>

Software is playing a crucial role in today's world. Software has evolved and changed its nature from domain specific problem solving to service providing industry in itself. The prominent application areas for software are Web Apps, Mobile applications, Cloud computing and Product line software. Software engineering focuses on problem understanding. Planning solution for solving the problem, executing the plan and testing the outcome generated against the specification for correctness and quality. Software engineering uses process, methods and tools for getting the desired outcome.<br>

A generic process model for software engineering consists of set of framework activities, umbrella activities, actions and work tasks. Different process models are defined based on different types of process flow supported by them.<br>

Waterfall and V-models are the oldest models which are sequential in nature. These models use linear flow. Incremental process models deliver early, working version of the software and are iterative in nature. Evolutionary process models are flexible to adapt changes and suggest incremental and iterative nature. Prototyping and spiral models are evolutionary process models Concurrent process models are iterative as well as parallel in nature. The unified process is a use case driven, architecture centric, iterative and incremental in nature.<br>

    </p>
</main>
</body>
</html>